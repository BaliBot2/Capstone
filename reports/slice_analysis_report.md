# Slice Size Distribution Analysis Report

## Executive Summary
This analysis evaluates the characteristics of slices generated by the Context Engine on the `libpng` codebase. The goal was to determine the optimal slice depth, understand the distribution of slice sizes, and identify any outliers.

**Key Findings:**
*   **Slice Size is Independent of Depth**: Increasing the slicing depth from 1 to 10 resulted in **zero increase** in slice size for all 20 sampled identifiers.
*   **Slices are Small**: The average slice size is **15.4 nodes** (approx. 13.75 lines of code). 55% of slices are "Tiny" (1-10 nodes).
*   **Intra-Procedural Limitation**: The flat depth curve confirms that the slicing is strictly intra-procedural. The slicer quickly exhausts the local data flow graph and cannot cross method boundaries.

## Test 1.1: Depth vs Size Curve
We performed backward slicing on 20 random identifiers at depths 1, 2, 3, 5, 7, and 10.

| Depth | Avg Nodes | Avg Lines | Avg Time (ms) |
|-------|-----------|-----------|---------------|
| 1     | 15.40     | 13.75     | 0.03          |
| 2     | 15.40     | 13.75     | 0.01          |
| 3     | 15.40     | 13.75     | 0.01          |
| 5     | 15.40     | 13.75     | 0.01          |
| 7     | 15.40     | 13.75     | 0.01          |
| 10    | 15.40     | 13.75     | 0.01          |

**Observation**: The identical metrics across all depths indicate that the slicer reaches the "end" of the available dependency graph within 1 hop (or effectively instantly). This is consistent with the lack of interprocedural edges in the CPG.

## Test 1.2: Size Distribution (Depth=5)
Using a standard depth of 5, we categorized the slice sizes:

*   **Tiny (1-10 nodes)**: 11 (55.0%)
*   **Small (11-30 nodes)**: 7 (35.0%)
*   **Medium (31-100 nodes)**: 2 (10.0%)
*   **Large (101+ nodes)**: 0 (0.0%)

**Statistics:**
*   **Mean**: 15.40 nodes
*   **Median**: 6.5 nodes
*   **Max**: 67 nodes

## Test 1.3: Outlier Investigation

### Smallest Slices (3-4 nodes)
*   Examples: `auxv`, `temp`, `argv`
*   **Cause**: These are likely local variables or parameters with very limited usage within a single function. Since there are no interprocedural edges, their "context" is limited to their immediate declaration and 1-2 usages.

### Largest Slices (30-67 nodes)
*   **Max Slice**: `p` in `main` (67 nodes)
*   **Second Largest**: `i` in `main` (45 nodes)
*   **Cause**: These are variables in the `main` function, which is typically the largest and most complex function in a C program. The "large" slice is simply reflecting the complexity of `main`'s local control flow and data dependencies. Even here, 67 nodes is relatively small for a "large" slice.

## Conclusion & Recommendations
1.  **Depth Parameter is Irrelevant**: For the current CPG, setting a depth > 1 is unnecessary.
2.  **Context is Limited**: The context provided to the LLM will be limited to the local function. This is good for token usage but bad for understanding complex, multi-function logic.
3.  **Next Steps**:
    *   To get "deep" slices, we **must** fix the interprocedural data flow generation in Joern (or switch tools).
    *   In the meantime, the Context Engine is fast and safe but limited to "Local Context".
